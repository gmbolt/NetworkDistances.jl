var documenterSearchIndex = {"docs":
[{"location":"interaction_networks/#Matching-distances","page":"Interaction Networks","title":"Matching distances","text":"","category":"section"},{"location":"interaction_networks/#Type-hierarchy","page":"Interaction Networks","title":"Type hierarchy","text":"","category":"section"},{"location":"interaction_networks/","page":"Interaction Networks","title":"Interaction Networks","text":"At the top level we have ","category":"page"},{"location":"interaction_networks/","page":"Interaction Networks","title":"Interaction Networks","text":"AbstractMatchingDistance <: SemiMetric","category":"page"},{"location":"interaction_networks/","page":"Interaction Networks","title":"Interaction Networks","text":"This encompasses all matching-based distances. Within this, we have two further abstract classes ","category":"page"},{"location":"interaction_networks/","page":"Interaction Networks","title":"Interaction Networks","text":"CompleteMatchingDistance <: AbstractMatchingDistance - these are the complete matching distances which optimise over complete matchings only (i.e. where all path from smaller observation are included in matching);\nGeneral{T} <: AbstractMatchingDistance where T <: CompleteMatchingDistance - these can have paths from both observations being unmatched. These are defined given complete matchings via General(d) where d::CompleteMatchingDistance.","category":"page"},{"location":"interaction_networks/#Other-methods","page":"Interaction Networks","title":"Other methods","text":"","category":"section"},{"location":"interaction_networks/","page":"Interaction Networks","title":"Interaction Networks","text":"get_cost_matrix_dynamic\r\nget_cost_matrix_fixed","category":"page"},{"location":"interaction_networks/#NetworkDistances.get_cost_matrix_dynamic","page":"Interaction Networks","title":"NetworkDistances.get_cost_matrix_dynamic","text":"get_cost_matrix_dynamic(d::AbstractMatchingDistance, X, Y)\n\nReturn cost matrix for evaluating matching-based distance between X and Y. \n\nThis is done \"dynamically\" in the sense that the first axis of the output matrix  will always correspond to the shorter of the two passed vectors X and Y.\n\n\n\n\n\n","category":"function"},{"location":"interaction_networks/#NetworkDistances.get_cost_matrix_fixed","page":"Interaction Networks","title":"NetworkDistances.get_cost_matrix_fixed","text":"get_cost_matrix_fixed(d::AbstractMatchingDistance, X, Y)\n\nReturn cost matrix for evaluating matching-based distance between X and Y. \n\nThis is \"fixed\" in the sense the first axis of output matrix always corresponds to X and the second to Y.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = NetworkDistances","category":"page"},{"location":"#NetworkDistances","page":"Introduction","title":"NetworkDistances","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for NetworkDistances.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [NetworkDistances]","category":"page"},{"location":"#NetworkDistances.Normalised","page":"Introduction","title":"NetworkDistances.Normalised","text":"Normalised distance obtained by applying Steinhaus transform to given distance. \n\nNote this will be a metric given d is a metric.\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDistances.Precomputed","page":"Introduction","title":"NetworkDistances.Precomputed","text":"Distance which just looks-up a cache of stored distances.\n\n\n\n\n\n","category":"type"},{"location":"#NetworkDistances.diffusion_dist-Tuple{Matrix{Int64}, Matrix{Int64}, Any}","page":"Introduction","title":"NetworkDistances.diffusion_dist","text":"Compute the diffusion distance between two adjacency matrices with t the time of diffusion.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.get_cost_matrix_dynamic-Union{Tuple{T}, Tuple{NetworkDistances.AbstractMatchingDistance, Vector{T}, Vector{T}}} where T","page":"Introduction","title":"NetworkDistances.get_cost_matrix_dynamic","text":"get_cost_matrix_dynamic(d::AbstractMatchingDistance, X, Y)\n\nReturn cost matrix for evaluating matching-based distance between X and Y. \n\nThis is done \"dynamically\" in the sense that the first axis of the output matrix  will always correspond to the shorter of the two passed vectors X and Y.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.get_cost_matrix_fixed-Union{Tuple{T}, Tuple{NetworkDistances.AbstractMatchingDistance, Vector{T}, Vector{T}}} where T","page":"Introduction","title":"NetworkDistances.get_cost_matrix_fixed","text":"get_cost_matrix_fixed(d::AbstractMatchingDistance, X, Y)\n\nReturn cost matrix for evaluating matching-based distance between X and Y. \n\nThis is \"fixed\" in the sense the first axis of output matrix always corresponds to X and the second to Y.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.get_info_deep-Union{Tuple{S}, Tuple{T}, Tuple{T, Vector{S}, Vector{S}}} where {T<:(Union{NetworkDistances.CompleteMatchingDistance, General{T}} where T<:NetworkDistances.CompleteMatchingDistance), S}","page":"Introduction","title":"NetworkDistances.get_info_deep","text":"get_info_deep(d::MatchingBasedDistance, X::Vector{Vector{S}}, Y::Vector{Vector{S}})\n\nReturns two vectors indicating which entries have been matched. An entry being true in the output implies this entry was matched with one in the other observation. \n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.hamming_dist-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Introduction","title":"NetworkDistances.hamming_dist","text":"Compute the Hamming distance between two adjacency matrices (directed graphs)\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.jaccard_dist-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Introduction","title":"NetworkDistances.jaccard_dist","text":"Compute the Jaccard distance between two adjacency matrices (directed graphs)\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.pre_compute-Union{Tuple{T}, Tuple{Distances.SemiMetric, Vector{T}}} where T","page":"Introduction","title":"NetworkDistances.pre_compute","text":"Constructor method which takes distance + collection of values and makes a pre-computed distance.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkDistances.progress_pairwise-Union{Tuple{T}, Tuple{Distances.SemiMetric, Vector{T}}} where T","page":"Introduction","title":"NetworkDistances.progress_pairwise","text":"Distance matrix calculation between elements of Vectors with progress bar.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.pairwise!-Tuple{AbstractArray, Distances.Metric, Vector, Vector}","page":"Introduction","title":"StatsAPI.pairwise!","text":"In-place distance matrix calculation between elements of Vectors.\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.pairwise!-Tuple{AbstractMatrix, Distances.Metric, Vector, Vector}","page":"Introduction","title":"StatsAPI.pairwise!","text":"In-place distance matrix calculation between elements of Vectors. (For SubArray)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.pairwise!-Tuple{SubArray, Distances.Metric, Vector, Vector}","page":"Introduction","title":"StatsAPI.pairwise!","text":"In-place distance matrix calculation between elements of Vectors. (For SubArray)\n\n\n\n\n\n","category":"method"},{"location":"#StatsAPI.pairwise-Union{Tuple{T}, Tuple{Distances.SemiMetric, Vector{T}, Vector{T}}} where T","page":"Introduction","title":"StatsAPI.pairwise","text":"Distance matrix calculation between elements of Vectors. This is a custom extension of the function in the Distances.jl package to allow vectors of general type. The function in Distances.jl is designed for univariate/multivariate data and so takes as input either vectors or matrices (data points as rows).\n\n\n\n\n\n","category":"method"}]
}
